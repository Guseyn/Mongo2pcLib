
###################################################

transaction = Transaction(id, rollbackId, transactionsCollection, ...operations);
transaction.invoke();
transaction.onCommit(commitCallback); // transactionCallback - (results) => {}
transaction.onRollback(rollbackCallback); // rollbackCallback - (results) => {}
recoveringProcess = RecoveringProcess(db, options); // recovery
recoveringProcess.start(onTransactionRecoveredCallback() {});


####################################################

Requests: 
	aggregate(collection, pipeline, options)
	bulkWrite(collection, operations, options)
	deleteMany(collection, filter, options)
	deleteOne(collection, filter, options)
	findOneAndDelete(collection, filter, options)
	findOneAndReplace(collection, filter, replacement, options)
	findOneAndUpdate(collection, filter, update, options)
	initializeOrderedBulkOp(collection, options)
	initializeUnorderedBulkOp(collection, options)
	insertMany(collection, docs, options)
	insertOne(collection, doc, options)
	replaceOne(collection, filter, doc, options)
	updateMany(collection, filter, update, options)
	updateOne(collection, filter, update, options)

operation = new Operation({
	request: findOneAndUpdate(collection, filter, update, options),
	rollbackRequest: findOneAndUpdate(collection, filter, rallbackUpdate, options),
	rallbackCondition: (operationNum, result) => {return true;},
	commitCondition: (operationNum, result) => {return true;}
})

request.rallbackCondition(operationNum, condition); // condition - (results) => {return boolean} - if conition is true after request executes, current transaction is being interrupted with new rollback transaction
request.commitCondition(operationNum, condition); // condition - (results) => {return boolean} - if conition is true after request executes, current transaction is being stopped on this request.

If rollback transaction fails then only recovery process can fix the problem, you can use error object for exploring what is wrong with operations in the transaction.
